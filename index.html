<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>A3</title>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="justices.js" charset="utf-8"></script>
    <style>
      body {
        -webkit-user-select: none; /* Chrome/Safari */        
        -moz-user-select: none; /* Firefox */  
        -ms-user-select: none;
        margin: 8;
      }
      .chart div {
        font: 10px sans-serif;
        background-color: white;
        text-align: left;
        padding: 3px;
        margin: 1px;
        color: white;
        width: 200px;
      }
      div.caseJusticeBox {
        display: inline;
        width: 100px;
      }
      .overlay {
          stroke-width: 0px;
          fill-opacity: 0.00;
      }
      .viewport {
          stroke: gray;
          fill: black;
          fill-opacity: 0.2;
      }

      .axis path,
      .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
      }

      .x.axis path {
          display: none;
      }
      .line {
          fill: none;
          /*stroke: steelblue;*/
          stroke: url(#line-gradient);
          stroke-width: 1.5px;
      }

      .clickable {
          cursor: pointer;
      }


      .hoverRect:hover {
        opacity: 0.5;
      }

      .tooltip {
        position: absolute;
        left: 620px;
        top: 100px;
        width: 200px;
        background-color: #ddd;
        display: none;
        padding: 5px;
        border-width: 2px;
        border-color: #aaa;
        border-style: solid;
      }
      .arrow-left {
            position: absolute;
            left: 600px;
			  width: 0; 
			  height: 0; 
			  border-top: 5px solid transparent;
			  border-bottom: 5px solid transparent; 
			  border-right:20px solid #aaa;
			  display: none; 
	    }
	    
      .zoom {
        fill: lightgray;
        fill-opacity: 0.5;
      }
      
      .justiceViewType {
        position: absolute;
        left: 800px;
        top: 150px;
      }

    </style>
  </head>
  <body>
  
    <!--svg class="i" width="50" height="50"> 
      <text x="0" y="0" fill="black">i</text>
    </svg-->
    <h1>Supreme Court Jukebox</h1>
    <p>
        This visualization shows ideological data about Supreme Court votes by justices between 1946 and 2014.
    </p>    <p>
        "Liberal" decisions are shown as blue circles in the main chart, "conservative" decisions are shown as red circles, and abstentions or other non-decisions are shown as gray circles (circles are absent for absent data). The background of each row shows the majority ideological direction, which corresponds to the final decision on each case. Clicking the row opens up Google search results for that case in a new browser tab. Clicking and dragging in the main chart, or using the mouse wheel over it, scrolls through the cases.
    </p>    <p>
        The summary time series in the scroll brush area shows overall ideological trends by computing a moving average of the ideological direction of the majority rulings in each case, with liberal coded as +1 and conservative coded as -1. The brush (grey rectangle) shows the time period currently displayed in the main chart. The scroll brush area allows to scroll across time periods by clicking and dragging the brush, and to quickly navigate to a certain time period by clicking in the scroll brush area.
    </p>    <p>
        Clicking on the name of a justice brings up a graph showing a running total of their decisions. If the "Liberal/conservative" radio button is selected, this running total is again computed with the +/-1 encoding for liberal/conservative, whereas selecting "Majority/minority" uses the +/-1 enconding for voting with the majority or with the minority. The gray reference line in these graphs shows the running total with the same encodings for the final decisions of the full court on each case. The grey selection shows the time period currently displayed in the main chart. Clicking the name of the justice in the title of these graphs opens up a Wikipedia page for that justice.
    </p>
    <div class="chart"></div>
    <div class="tooltip"></div>
    <div class="arrow-left"></div>
  </body>

<script type="text/javascript">

d3.json("justices.json", function(error, json) {
    var justiceDataMap = {};
    if (error) return console.warn(error);
    for (var k = 0; k < json.justices.length; k++) {
        var elem = json.justices[k];
        justiceDataMap[+elem.id] = [elem.name, elem.link, elem.president];
    }

var dateFormat = d3.time.format("%m/%-d/%Y");
//d3.csv("data/scd_since2000.csv", function(d) {
//d3.csv("data/scd_since1957.csv", function(d) {
d3.csv("data/SCDB_2014_01_justiceCentered_Citation.csv", function(d) {
  return {
    caseId: d.caseId,
    decisionDate: dateFormat.parse(d.dateDecision), // convert to Date
    justiceName: d.justiceName,
    justiceID: +d.justice,
    vote: +d.direction,
    decision: +d.decisionDirection,
    majority: +d.majority,
    name: d.caseName
  };
}, function(error, rows) {

  // sort all cases by decision date
  rows.sort(function(a,b) {return d3.ascending(a.decisionDate, b.decisionDate)});

  // create a nested structure grouping all jusice decisions by case
  var nestedByCaseId = d3.nest().key(function(d) { return d.caseId; }).entries(rows);
    
  var numCases = nestedByCaseId.length;
  var lastJustice = 0;

  // compute first and last active cases for all justices
  var firstCases = {};
  var lastCases = {};
  var libTotal = 0;
  var consTotal = 0;
  var movingAverage = 0;
  var movingAverageBin = 50;

  for (var i = 0; i < numCases; i ++ ) {
    for (var j = 0; j < nestedByCaseId[i].values.length; j++) {
      var justice = nestedByCaseId[i].values[j].justiceID;
      lastJustice = Math.max(justice,lastJustice);
      if (firstCases[justice] == undefined) {
        firstCases[justice] = i;
      }
      lastCases[justice] = i;
      if (nestedByCaseId[i].values[j].decision == 1) {
        consTotal = consTotal + 1;
      } else if (nestedByCaseId[i].values[j].decision == 2) {
        libTotal = libTotal + 1;
      }
    }
    nestedByCaseId[i].num = i;
    var decisionForAverage = 0;
    if (libTotal > 5) {
      nestedByCaseId[i].overallDecision = 2;
      decisionForAverage = 1;
    } else if (consTotal > 5) {
      nestedByCaseId[i].overallDecision = 1;
      decisionForAverage = -1;
    } else {
      nestedByCaseId[i].overallDecision = 3;
    }

    nestedByCaseId[i].decisionForAverage = decisionForAverage;

    if (i < movingAverageBin) {
      movingAverage = ( (movingAverage * i) + decisionForAverage ) / (i + 1);
    } else {
      movingAverage = movingAverage - (nestedByCaseId[i - movingAverageBin].decisionForAverage/movingAverageBin) + decisionForAverage/(movingAverageBin);
    }

    nestedByCaseId[i].movingAverage = movingAverage;

    libTotal = 0;
    consTotal = 0;

  }
  //console.log(firstCases);
  //console.log(lastCases);

  //for (i in firstCases) {
  //  console.log(i + ": " + firstCases[i] + " -> " + lastCases[i]);
  //}

  // compute the break-points, i.e. when the set of active justices change
  var activeJustices = d3.set();

  // initialize active justices with the justices who decided the first case in the DB
  for (var j = 0; j < nestedByCaseId[0].values.length; j++) {
	  activeJustices.add(nestedByCaseId[0].values[j].justiceID);
  }
 
  var breakpoints = [];
  var activeJusticesByBreakpoint = [activeJustices.values()];
  var justiceAdditionsByBreakpoint = [];
  var justiceRemovalsByBreakpoint = [];
  while (true) {
    // find the next justice to leave
    var nextToLeave = activeJustices.values()[0];
    for (j = 1; j < activeJustices.size(); j++) {
      if (lastCases[activeJustices.values()[j]] < lastCases[nextToLeave]) {
        nextToLeave = activeJustices.values()[j];
      }
    }
        
    if (lastCases[nextToLeave] == (numCases - 1)) { break; }
    //console.log("next to leave: " + nextToLeave);
    activeJustices.remove(nextToLeave);
    var nextToArrive = lastJustice;
    for (j in firstCases) {
      if (firstCases[j] > lastCases[nextToLeave] && firstCases[j] < firstCases[nextToArrive] && !activeJustices.has(j)) {
        nextToArrive = j;
      }
    }
    //console.log("next to arrive: " + nextToArrive);
    activeJustices.add(nextToArrive);
    breakpoints.push(lastCases[nextToLeave]+1);
    activeJusticesByBreakpoint.push(activeJustices.values());
    justiceAdditionsByBreakpoint.push(nextToArrive);
    justiceRemovalsByBreakpoint.push(nextToLeave);
  }
  breakpoints.push(numCases);
    
  // compute justice column per region of the chart
  justiceColumnsByBreakpoint = [];
  for (i in activeJusticesByBreakpoint) {
    var justiceColumns = {};
    for (var j=0; j<9; j++) {
      justiceColumns[activeJusticesByBreakpoint[i][j]] = j;
    }
    justiceColumnsByBreakpoint.push(justiceColumns);
  }
  
  //console.log(breakpoints);
  //console.log(activeJusticesByBreakpoint);
  //console.log(justiceColumnsByBreakpoint);
  
  // add breakpoints to data
  for (i in nestedByCaseId) {
    var bp = 0;
    while (breakpoints[bp] <= i) { bp++; }
    for (var j=0; j<nestedByCaseId[i].values.length; j++) {
      nestedByCaseId[i].values[j].breakpoint = bp;
    }
  }
  
  // set up size variables
  
  //console.log(window.innerWidth);
  //console.log(window.innerHeight);

  var h1Height = d3.select("h1")[0][0].clientHeight;
  var bodyMargin = 8; //d3.select("body").style("margin");

  var headerHeight = 160;
  var rowHeight = 32;
  var boxesInView = Math.max(1,Math.floor((window.innerHeight - bodyMargin - h1Height - headerHeight)/rowHeight)-1); //13;
  var yMax = rowHeight*(numCases-boxesInView);
  
  var columnWidth = 45;
  
  var gridWidth = 9*columnWidth;
  var gridHeight = boxesInView*rowHeight;
    
  var axisWidth = 60;
  var scrollWidth = 100;
  var zoomWidth = 30;
  var sideLabelWidth = 125;

  var justiceViewWidth = 650;
  var justiceViewHeight = 400;
    
  var labelAngle = -60;
  
  var startCase = 0;
  
  // x-coordinates of region beginnings
  var axisTranslate = 0;
  var scrollTranslate = axisTranslate + axisWidth;
  var zoomTranslate = scrollTranslate + scrollWidth;
  var gridTranslate = zoomTranslate + zoomWidth;
  var sideLabelTranslate = gridTranslate + gridWidth;
  var justiceViewTranslate = sideLabelTranslate + sideLabelWidth;

  // set up x and y scales
  var xScale = d3.scale.linear()
    .domain([0, 9])
    .range([0, gridWidth]),
      
      yScale = d3.scale.linear()
    .domain([0, numCases-1])//startCase+boxesInView])
    .range([0, gridHeight]);

  yScale.domain([startCase, boxesInView]);
  
  // set up SVG
  var svg = d3.select("body").append("svg")
                                    .attr("class", "svg")
                                    .attr("width", axisWidth + scrollWidth + zoomWidth + gridWidth + sideLabelWidth + justiceViewWidth)
                                    .attr("height", gridHeight + headerHeight);

  var justiceViewSpace = svg.append("g")
                      .attr("class", "justiceViewSpace")
                      .attr("transform", "translate(" + justiceViewTranslate + "," + headerHeight +")" )
                      .attr("width", justiceViewWidth)
                      .attr("height", justiceViewHeight);

  var scrollBrush = svg.append("g")
                      .attr("class", "scrollBrush")
                      .attr("transform", function(d) { return "translate("+scrollTranslate+"," +headerHeight+")"; })
                      .attr("width", scrollWidth)
                      .attr("height", gridHeight);
                      
  var brushXScale = d3.scale.linear() 
          .domain([-1, 1])
          .range([0, scrollWidth]),
      brushYScale = d3.scale.linear()
          .domain([0, numCases])
          .range([0, gridHeight]);

  scrollLine = d3.svg.line()
          .x(function(d) { return brushXScale(d.movingAverage); })
          .y(function(d) { return brushYScale(d.num); });

  scrollAxis = d3.svg.line()
          .x(function(d) { return brushXScale(0); })
          .y(function(d) { return brushYScale(d.num); });

  scrollBrush.append("path")
          .datum(nestedByCaseId)
          .attr("class", "line")
          .style("stroke", "grey")
          .attr("d", scrollAxis);

    scrollBrush.append("linearGradient")
            .attr("id", "ma-gradient")
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", brushXScale(-1)).attr("y1", 0)
            .attr("x2", brushXScale(1)).attr("y2", 0)
            .selectAll("stop")
            .data([
                {offset: "0%", color: "darkred"},
                {offset: 0.5, color: "darkred"},
                {offset: 0.5, color: "steelblue"},
                {offset: "100%", color: "steelblue"}
            ])
            .enter().append("stop")
            .attr("offset", function(d) { return d.offset; })
            .attr("stop-color", function(d) { return d.color; });

  scrollBrush.append("path")
          .datum(nestedByCaseId)
          .attr("class", "line")
          .style("stroke", "url(#ma-gradient)")
          .attr("d", scrollLine);

  var brush = scrollBrush.append("g")
      .attr("transform","translate(0,0)");
      
  var brushing = false;
  brush.append("rect")
      .attr("width",scrollWidth)
      .attr("height",5)
      .attr("style", "fill:gray; fill-opacity: 0.5;");
      
  scrollBrush.append("rect")
      .attr("width", scrollWidth)
      .attr("height", gridHeight)
      .attr("style", "fill-opacity: 0")
      .on("mousedown",function() { 
         var caseNum = (d3.event.clientY - svg[0][0].getBoundingClientRect().top - headerHeight)
            / gridHeight * numCases; 
          //console.log(caseNum);
          updateScrollY(caseNum);
          brushing = true;
      })
      .on("mousemove",function() {
        if (brushing) {
          var caseNum = (d3.event.clientY - svg[0][0].getBoundingClientRect().top - headerHeight)
            / gridHeight * numCases; 
          //console.log(caseNum);
          updateScrollY(caseNum);
        }
      })
      .on("mouseup",function() {
        //console.log("unclicked brush");
        brushing = false;
      })
      .on("mouseout",function() {
        brushing = false;
      });

  // add zoom polygon  
  var zoomPoly = svg.append("polygon")
     .attr("class","zoom")
     .attr("stroke","gray")
     .attr("points",zoomTranslate+" "+headerHeight+" "+gridTranslate+" "+headerHeight+
       " "+gridTranslate+" "+(headerHeight+gridHeight)+" "+zoomTranslate+" "+(headerHeight+5));
 
  var svgContainer = svg.append("g")
                        .attr("class", "svgContainer");



  var computeYearBreaks = function() {
    var breaks = d3.map();
    var curYear = null;
    for (i = 0; i < numCases; i++) {
      var year = nestedByCaseId[i].values[0].decisionDate.getFullYear();
      if (year !== curYear) {
        breaks.set(i,year);
        curYear = year;
      }
    }
    return breaks;
  };

  var yearBreaks = computeYearBreaks();
  var tickPeriod = 4;
  var tickYears = yearBreaks.keys().filter(function(d,i) {return i % tickPeriod == 0;});
  // set up and add y axis
  var yAxis = d3.svg.axis()
    .scale(brushYScale)
    .orient("left")
//    .ticks(yearBreaks.keys.length)
    .tickValues(tickYears)
    .tickFormat(function(d) {
            return yearBreaks.get(d);
          });
//    .tickFormat(function(d) { return d + ' (' + runningTotalData[d].date.getFullYear() + ')'; });
    //.ticks(8);
    
  svgContainer.append("g")
    .attr("class", "y axis") 
    .attr("transform", "translate("+axisWidth+"," + headerHeight + ")")
    .call(yAxis);
   
  // set up grid
  var mainChart = svgContainer.append("g")
                              .attr("class", "mainChart")
                              .attr("transform", function(d) { return "translate(" + gridTranslate + "," +headerHeight+")"; })
                              .attr("width", gridWidth)
                              .attr("height", gridHeight);
              
  // set up and add header
  var header = svgContainer.append("g")
    .attr("class", "header")
    .attr("transform", "translate(" + (gridTranslate-1) + ",0)")
    .attr("width", gridWidth)
    .attr("height", headerHeight);
  header.append("rect")
    .attr("width", gridWidth + sideLabelWidth)
    .attr("height", headerHeight)
    .attr("style","fill:white");
  for (var i=0; i<9; i++) {
    header.append("text")
      .attr("transform","translate("+(columnWidth*(i+0.5))+","+(headerHeight-5)+")rotate("+labelAngle+")")
      .attr("class","label"+i)
      .style("cursor: pointer;");
      //.text("justice " + i);
  }
  
  // set up side label
  var sideLabel = mainChart.append("text")
    .attr("class", "clickable")
    .attr("transform","translate("+gridWidth+",0)")
    .text("");
               
  // draw lines
  for (var i=0; i<9; i++) {
    mainChart.append("line")
      .attr("x1",columnWidth*(i+0.5)).attr("y1",yScale(0))
      .attr("x2",columnWidth*(i+0.5)).attr("y2",yScale(breakpoints[0]-0.5))
      .attr("stroke-width",6)
      .attr("stroke","lightgray");
  }
  for (var i=1; i<breakpoints.length; i++) {
    var lastbp = breakpoints[i-1];
    var bp = breakpoints[i];
    // connecting line
    for (var j=0; j<9; j++) {
      var justiceID = activeJusticesByBreakpoint[i-1][j];
      var thisColumn = justiceColumnsByBreakpoint[i][justiceID];
      if (thisColumn != undefined) {
        var lastColumn = justiceColumnsByBreakpoint[i-1][justiceID];
        mainChart.append("line")
          .attr("x1",columnWidth*(lastColumn+0.5)).attr("y1",yScale(lastbp-0.5))
          .attr("x2",columnWidth*(thisColumn+0.5)).attr("y2",yScale(lastbp+0.5))
          .attr("stroke-width",6)
          .attr("stroke","lightgray");
      }
    }
    mainChart.append("line")
      .attr("x1",columnWidth*(8.5)).attr("y1",yScale(lastbp+0.5))
      .attr("x2",columnWidth*(8.5)+30).attr("y2",yScale(lastbp+0.5))
      .attr("stroke-width",6)
      .attr("stroke","lightgray");
    // straight line
    for (var j=0; j<9; j++) {
      mainChart.append("line")
        .attr("x1",columnWidth*(j+0.5)).attr("y1",yScale(lastbp+0.5))
        .attr("x2",columnWidth*(j+0.5)).attr("y2",yScale(bp-0.5))
        .attr("stroke-width",6)
        .attr("stroke","lightgray");
    }
  }

  function zoomer(d) { 
    return d.num*rowHeight; 
  }

  var overlay = d3.svg.area()
      .y(zoomer)
      .x0(0)
      .x1(gridWidth);

  mainChart.append('path')
      .attr('class', 'overlay')
      .attr('d', overlay(nestedByCaseId));
    

  // vars and function for srolling
  var scrollMultiplier = 0.01255;
  var scrollY = 0;
  var dragging = false;
  var lastMouseY;
  
  function updateScrollY(newScrollY) {
    scrollY = Math.min(Math.max(0,newScrollY),numCases-boxesInView);
    yScale.domain([scrollY, scrollY+boxesInView]);
    svgContainer.select(".y.axis").call(yAxis);

    // update chart
    mainChart.attr("transform","translate(" + gridTranslate + "," + (-scrollY*rowHeight+headerHeight) + ")");
    fillGrid();
    
    // update brush
    //viewport.extent(yScale.domain());
    //scrollBrush.select('.viewport').call(viewport);
    var brushCenter = gridHeight*((scrollY-boxesInView/2)/numCases);
    brush.attr("transform","translate(0,"+brushCenter+")");
    
    // update zoom
    zoomPoly.attr("points",zoomTranslate+" "+(headerHeight+brushCenter)+" "+gridTranslate+" "+headerHeight+
       " "+gridTranslate+" "+(headerHeight+gridHeight)+" "+zoomTranslate+" "+(headerHeight+brushCenter+5));
 
    
    // update labels      
    var bp = 0;
    while (breakpoints[bp] <= (yScale.domain()[0]-1)) { bp++; }
    applyLabels(bp);

    // update justice view
    updateJusticeViewSelection(scrollY);
    
  }
  
  // set up mouse events for main chart
  mainChart
    .on("wheel",function() { 
      updateScrollY(scrollY + d3.event.deltaY*scrollMultiplier);
      d3.select(".tooltip").style("display","none");
      d3.select(".arrow-left").style("display","none");
      d3.event.preventDefault();
    })
    .on("mousedown",function() {
      dragging = true;
      lastMouseY = d3.event.clientY;
    })
    .on("mousemove",function() {
      if (dragging) {
        updateScrollY(scrollY - (d3.event.clientY - lastMouseY)/rowHeight);
        lastMouseY = d3.event.clientY;
      }
    })
    .on("mouseup",function() {
      dragging = false;
    })
    .on("mouseout",function() {
      if (dragging && 
        (d3.event.clientY <= headerHeight + svg[0][0].getBoundingClientRect().top
         || d3.event.clientY >= svg[0][0].getBoundingClientRect().bottom
         || d3.event.clientX <= mainChart[0][0].getBoundingClientRect().left
         || d3.event.clientX >= mainChart[0][0].getBoundingClientRect().right)) {
        //updateScrollY(scrollY + (d3.event.clientY - lastMouseY)/rowHeight);
        dragging = false;
      }
    });
  
  // set up overlay to catch off-element scrolling events

  // fill grid 
  function fillGrid() {  
  
  var dataJoin = mainChart.selectAll("g")
    .data(nestedByCaseId.filter(function(d) {
      return d.num >= (scrollY - 1) && d.num <= (scrollY + boxesInView);
    }));            
  
  // remove exit rows  
  dataJoin.exit().remove();
   
  // update row transforms      
  dataJoin.attr("transform", function(d, i) { return "translate(0," + (rowHeight*d.num) + ")"; })
    .on("mouseover",function(d) { 
            var top = ((d.num - scrollY)*rowHeight + document.body.scrollTop + headerHeight + svg[0][0].getBoundingClientRect().top - 2);
            tooltip = d3.select(".tooltip")
              .style("display","block")
              .style("top",top+"px")
              .html("<strong>Case name: </strong>"+d.values[0].name+"<br / ><strong>Decided: </strong>"
                 + dateFormat(d.values[0].decisionDate));
            d3.select(".arrow-left")
              .style("display","block")
                            .style("top",((d.num +0.5 - scrollY)*rowHeight + document.body.scrollTop + headerHeight + svg[0][0].getBoundingClientRect().top - 2)+"px");
            console.log(window.innerHeight + " v " + d3.select(".tooltip")[0][0].getBoundingClientRect().bottom);
            var distFromBottom = window.innerHeight - d3.select(".tooltip")[0][0].getBoundingClientRect().bottom;
            if (distFromBottom < 10) {
              tooltip.style("top",(top+distFromBottom-10)+"px");
            }
          })
          .on("click",function(d) { window.open("https://www.google.com/?gws_rd=ssl#q="+d.values[0].name,"_blank"); } );;
  
  dataJoin.select("rect").attr("style", function(d) { 
          var text = "";
          if (d.overallDecision == 1) { 
            text = text +  "fill:darkred;stroke:darkred;" 
          } else if (d.overallDecision == 2) { 
            text = text + "fill:steelblue;stroke:steelblue;"; 
          } else { 
            text = text + "fill:lightgray;stroke:lightgray;"; 
          } 

          text = text + "fill-opacity:0.15;stroke-width:0;stroke-opacity:0.4;pointer-events: all;";
          return text;
        })
  
  var rowJoin = dataJoin.selectAll("circle")
    .data(function(d) { return d.values; });
  rowJoin.attr("cx",function(d,i,j) {
          var justice = d.justiceID;
          var bp = d.breakpoint;
          var column = justiceColumnsByBreakpoint[bp][justice];
          return columnWidth*(column + 0.5);
        })
        //.attr("cy",rowHeight/2).attr("r",(rowHeight-8)/2)
        .attr("style",function(d) { if (d.vote == 1) { return "fill:darkred;" } else if (d.vote == 2) { return "fill:steelblue;"; } else { return "fill:gray;"; } });
  rowJoin.enter().append("circle")
        .attr("class","clickable")
        .attr("cx",function(d,i,j) {
          var justice = d.justiceID;
          var bp = d.breakpoint;
          var column = justiceColumnsByBreakpoint[bp][justice];
          return columnWidth*(column + 0.5);
        })
        .attr("cy",rowHeight/2).attr("r",(rowHeight-8)/2)
        .attr("style",function(d) { if (d.vote == 1) { return "fill:darkred;" } else if (d.vote == 2) { return "fill:steelblue;"; } else { return "fill:gray;"; } });
          
  rowJoin.exit().remove();  
        
  var newRow = dataJoin.enter().append("g")
      .attr("transform", function(d, i) { return "translate(0," + (rowHeight*i) + ")"; });

  newRow.append("rect")
        .attr("width", gridWidth)
        .attr("height", rowHeight)
        .attr("class", "hoverRect clickable")
        .attr("style", function(d) { 
          
          var text = "";
          if (d.overallDecision == 1) { 
            text = text +  "fill:darkred;stroke:darkred;" 
          } else if (d.overallDecision == 2) { 
            text = text + "fill:steelblue;stroke:steelblue;"; 
          } else { 
            text = text + "fill:lightgray;stroke:lightgray;"; 
          } 

          text = text + "fill-opacity:0.15;stroke-width:0;stroke-opacity:0.4;pointer-events: all;";
          return text;
        })
        .on("mouseover",function(d) { 
            var top = ((d.num - scrollY)*rowHeight + document.body.scrollTop + headerHeight + svg[0][0].getBoundingClientRect().top - 2);
            tooltip = d3.select(".tooltip")
              .style("display","block")
              .style("top",top+"px")
              .html("<strong>Case name: </strong>"+d.values[0].name+"<br / ><strong>Decided: </strong>"
                 + dateFormat(d.values[0].decisionDate));
            d3.select(".arrow-left")
              .style("display","block")
                            .style("top",((d.num +0.5 - scrollY)*rowHeight + document.body.scrollTop + headerHeight + svg[0][0].getBoundingClientRect().top - 2)+"px");
            console.log(window.innerHeight + " v " + d3.select(".tooltip")[0][0].getBoundingClientRect().bottom);
            var distFromBottom = window.innerHeight - d3.select(".tooltip")[0][0].getBoundingClientRect().bottom;
            if (distFromBottom < 10) {
              tooltip.style("top",(top+distFromBottom-10)+"px");
            }
          })
          .on("mouseout",function(d) {
            d3.select(".tooltip").style("display","none");
            d3.select(".arrow-left").style("display","none");
          })
          .on("click",function(d) { window.open("https://www.google.com/?gws_rd=ssl#q="+d.values[0].name,"_blank"); } );


  var dot = newRow.selectAll("circle")
    .data(function(d) { return d.values; }).enter().append("circle")
        .attr("class","clickable")
        .attr("cx",function(d,i,j) {
          var justice = d.justiceID;
          var bp = d.breakpoint;
          var column = justiceColumnsByBreakpoint[bp][justice];
          return columnWidth*(column + 0.5);
        })
        .attr("cy",rowHeight/2).attr("r",(rowHeight-8)/2)
        .attr("style",function(d) { if (d.vote == 1) { return "fill:darkred;" } else if (d.vote == 2) { return "fill:steelblue;"; } else { return "fill:gray;"; } });
          
          
   } 
   fillGrid();      
 
  // set up legend
  svg.append("g")
    .attr("class","i")
    .append("text").text("hello");
  
  // setup function for applying labels
  function applyLabels(breakpoint) {
    for (var i=0; i<9; i++) {
        (function( lockedInIndex ) {
          var justiceID = activeJusticesByBreakpoint[breakpoint][lockedInIndex];
          header.select(".label"+lockedInIndex)
            //.attr("class", "clickable")
            .style("opacity","1")
            .attr("transform","translate("+(columnWidth*(lockedInIndex+0.5))+","+(headerHeight-5)+")rotate("+labelAngle+")")
            .text(justiceDataMap[justiceID][0])
                  .on("mouseover",function() {
                    d3.select(this).attr("style","font-weight: bold; cursor: pointer; ");
                  })
                  .on("mouseout",function() {
                    d3.select(this).attr("style","font-weight: normal; cursor: pointer;");
                  })

                  .on("click", function () {
                      showJusticeViewAndControls(justiceID);
                  });
        }(i));
    }
    
    if (breakpoints[breakpoint] <= yScale.domain()[1]) {
      //console.log(scrollY + "," + breakpoints[breakpoint] + "," + yScale.domain()[1]);
      var addedJustice = justiceAdditionsByBreakpoint[breakpoint];
      sideLabel.text(justiceDataMap[addedJustice][0])
        .attr("transform","translate("+(gridWidth+10)+","+((breakpoints[breakpoint]+0.5)*rowHeight+5)+")")
        .on("mouseover",function() {
                    d3.select(this).attr("style","font-weight: bold; cursor: pointer; ");
                  })
                  .on("mouseout",function() {
                    d3.select(this).attr("style","font-weight: normal; cursor: pointer;");
                  })
        .on("click", function () {
            showJusticeViewAndControls(addedJustice);
        });
      var t = scrollY - breakpoints[breakpoint];
      if (t < 1 && t > 0) {
        //console.log("transition w/ t=" + t);
        var leavingJustice = justiceRemovalsByBreakpoint[breakpoint];
        //console.log("leaving justice is " +justiceDataMap[leavingJustice][0] +" ("+justiceColumnsByBreakpoint[breakpoint][leavingJustice]+")");
        header.select(".label"+justiceColumnsByBreakpoint[breakpoint][leavingJustice])
           .style("opacity",1-t);
        for (j = 1; j<9; j++) {
          var justiceID = activeJusticesByBreakpoint[breakpoint][j];
          if (justiceColumnsByBreakpoint[breakpoint+1][justiceID] !== j) {
            console.log(justiceDataMap[justiceID][0] + "moving over");
            header.select(".label"+j)
              .attr("transform","translate("+(columnWidth*(j-t+0.5))+","+(headerHeight-5)+")rotate("+labelAngle+")");
          }
        }
      }
    } else {
      sideLabel.text("");
    }
  }
  
  applyLabels(0);

  //svgContainer.call(zoom);

    var computeRunningTotal = function(justiceId) {
        var firstCase = firstCases[justiceId];
        var lastCase = lastCases[justiceId];
        var data = [];
        var dates = [];
        var directionTotal = 0;
        var majorityTotal = 0;
        var decisionTotal = 0;
        for (i = firstCase; i <= lastCase; i++) {
            for (var j = 0; j < nestedByCaseId[i].values.length; j++) {
                var justice = nestedByCaseId[i].values[j].justiceID;
                if (justice === justiceId) {
                    if (nestedByCaseId[i].values[j].decision !== 3) {
                        directionTotal += (nestedByCaseId[i].values[j].vote === 2 ? 1 : -1);
                    }
                    majorityTotal += (nestedByCaseId[i].values[j].majority === 2 ? 1 : -1);
                    if (nestedByCaseId[i].values[j].decision !== 3) {
                        decisionTotal += (nestedByCaseId[i].values[j].decision === 2 ? 1 : -1);
                    }
                    data.push({"date": nestedByCaseId[i].values[j].decisionDate,
                        "direction_total": directionTotal,
                        "majority_total": majorityTotal,
                        "decision_total": decisionTotal});
                }
            }
        }
        data.sort(function(a,b) {return d3.ascending(a.date, b.date)});
        return data;
    };

  var computeYearBreaksForJustice = function(justiceId) {
    var firstCase = firstCases[justiceId];
    var lastCase = lastCases[justiceId];
    var breaks = d3.map();
    var curYear = null;
    for (i = firstCase; i <= lastCase; i++) {
      for (var j = 0; j < nestedByCaseId[i].values.length; j++) {
        var justice = nestedByCaseId[i].values[j].justiceID;
        if (justice === justiceId) {
          var year = nestedByCaseId[i].values[j].decisionDate.getFullYear();
          if (year !== curYear) {
            breaks.set(i-firstCase, year);
            curYear = year;
          }
        }
      }
    }
    return breaks;
  };

    var showJusticeViewAndControls = function(justiceID) {
        var controlNames = ["Liberal/conservative", "Majority/minority"];
        var values = ["direction", "majority"];
        var curValue = values[0];
        if (d3.select('input[name="justiceViewType"]:checked').node() !== null) {
            curValue = d3.select('input[name="justiceViewType"]:checked').node().value;
        }
        d3.select("form.justiceViewType").remove();
        var form = d3.select("body").append("form").attr("class", "justiceViewType")
           .style("top",(svg[0][0].getBoundingClientRect().top+50+document.body.scrollTop) + "px");
        var labelEnter = form.selectAll("span")
                .data(controlNames)
                .enter().append("div");
        labelEnter.append("input")
                .attr({
                    type: "radio",
                    name: "justiceViewType",
                    value: function(d, i) {return values[i];}
                })
                .property("checked", function(d, i) {return values[i]===curValue;});

        labelEnter.append("label").text(function(d) {return d;});
        showJusticeView(+justiceID);
    };
    
    window.onresize = function() {
      var form = d3.select("form.justiceViewType");
      form.style("top",(svg[0][0].getBoundingClientRect().top+50+document.body.scrollTop) + "px");
    }

    var showJusticeView = function(justiceId) {
        var controlValue = d3.select('input[name="justiceViewType"]:checked').node().value;
        d3.selectAll('input[name="justiceViewType"]')
                .on("click", function () {
                    showJusticeView(justiceId);
                });
        var runningTotalData = computeRunningTotal(justiceId);

        var margin = {top: 30, right: 20, bottom: 45, left: 75},
                width = 650 - margin.left - margin.right,
                height = 350 - margin.top - margin.bottom;

//        var x = d3.time.scale()
//                .range([0, width]);
        var x = d3.scale.linear()
                .range([0, width]);

        var y = d3.scale.linear()
                .range([height, 0]);


    var yearBreaksForJustice = computeYearBreaksForJustice(justiceId);
    var tickNumber = 4;
    var tickPeriod = Math.round(yearBreaksForJustice.size()/tickNumber);
    var minDistance = 30; // only take labels that are at least this far apart in number of cases

    var tickYearsForJustice = [];
    var lastTick = null;
    var allTicks = yearBreaksForJustice.keys();
    allTicks.sort(function(a,b) {return d3.ascending(+a,+b);});
    for (var k = 0; k < allTicks.length; k++) {
        if (k % tickPeriod == 0) {
            if (lastTick === null || (allTicks[k]-lastTick) > minDistance) {
                lastTick = allTicks[k];
                tickYearsForJustice.push(lastTick)
            }
        }
    }
//  var tickYearsForJustice = yearBreaksForJustice.keys().filter(function(d,i) {return i % tickPeriod == 0;});
    // set up and add y axis
      var xAxis = d3.svg.axis()
              .scale(x)
              .orient("bottom")
              .tickValues(tickYearsForJustice)
              .tickFormat(function(d) {
                  return yearBreaksForJustice.get(d);
              });

        var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

        var yMin = d3.min(runningTotalData, function(d) { return controlValue === "direction" ? Math.min(d.direction_total, d.decision_total) : Math.min(d.majority_total, d.decision_total); });
        var yMax = controlValue === "direction" ? d3.max(runningTotalData, function(d) { return Math.max(d.direction_total, d.decision_total); }) : runningTotalData.length;
//        x.domain(d3.extent(runningTotalData, function(d) { return d.date; }));
        x.domain([0, runningTotalData.length]);
        y.domain([yMin, yMax]);

        var line1;
        var line2 = null;
        if (controlValue === "direction") {
            line1 = d3.svg.line()
//                    .x(function(d) { return x(d.date); })
                    .x(function(d,i) { return x(i); })
                    .y(function(d) { return y(d.direction_total); });
            line2 = d3.svg.line()
//                    .x(function(d) { return x(d.date); })
                    .x(function(d,i) { return x(i); })
                    .y(function(d) { return y(d.decision_total); });

        } else {
            line1 = d3.svg.line()
//                    .x(function(d) { return x(d.date); })
                    .x(function(d,i) { return x(i); })
                    .y(function(d) { return y(d.majority_total); });
            line2 = d3.svg.line()
//                    .x(function(d) { return x(d.date); })
                    .x(function(d,i) { return x(i); })
                    .y(function(d,i) { return y(i); });

        }


        d3.select("body").selectAll("g.justiceView").remove();
        var svg2 = justiceViewSpace
                .append("g")
                .attr("class", "justiceView")
                .attr("justiceId", justiceId)
                .attr("width", width + margin.left + margin.right)
                .attr("graphWidth", width)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        svg2.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis)
                .append("text")
                .attr("x", width-5)
                .attr("dy", "1em")
                .style("text-anchor", "end");
//                .text("Cases (Date)");

        svg2.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -65)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text(controlValue === "direction" ? "Liberal votes running total" : "Majority votes running total");

        var zeroPercent = Math.abs(yMin/(yMax - yMin));
        svg2.append("linearGradient")
                .attr("id", "line-gradient")
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("x1", 0).attr("y1", y(yMin))
                .attr("x2", 0).attr("y2", y(yMax))
                .selectAll("stop")
                .data([
                    {offset: "0%", color: "darkred"},
                    {offset: zeroPercent, color: "darkred"},
                    {offset: zeroPercent, color: "steelblue"},
                    {offset: "100%", color: "steelblue"}
                ])
                .enter().append("stop")
                .attr("offset", function(d) { return d.offset; })
                .attr("stop-color", function(d) { return d.color; });


        svg2.append("path")
                .datum(runningTotalData)
                .attr("class", "line")
    //          .stroke: url(#line-gradient);*/
                .attr("d", line1);
        svg2.append("path")
                .datum(runningTotalData)
                .attr("class", "line")
                .style("stroke", "grey")
                .attr("d", line2);

        svg2.append("text")
                .attr("x", (width / 2))
                .attr("y", 0 - (margin.top / 2))
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text(justiceDataMap[justiceId][0])
                .on("mouseover",function() {
                  d3.select(this).attr("style","font-weight: bold; cursor: pointer; ");
                })
                .on("mouseout",function() {
                  d3.select(this).attr("style","font-weight: normal; cursor: pointer;");
                })
                .on("click",function(d) {
                  window.open(justiceDataMap[justiceId][1]);
                });


        var insertLineBreaks = function (d) {
          var el = d3.select(this);
          var words = el.text().split(' ');
          el.text('');

          for (var i = 0; i < words.length; i++) {
            var tspan = el.append('tspan').text(words[i]);
            if (i > 0)
              tspan.attr('x', el.attr('x')).attr('dy', '1em');
          }
        };

//        svg2.selectAll('g.x.axis g text').each(insertLineBreaks);
//        svg2.selectAll('g.x.axis text').each(insertLineBreaks);


      var selection = svg2.append("g")
              .attr("class", "selection")
              .attr("transform","translate(0,0)");
      selection.append("rect")
              .attr("width",5)
              .attr("height",height)
              .attr("style", "fill:gray; fill-opacity: 0.5;");
      var length = lastCases[justiceId]-firstCases[justiceId];
      selection.attr("transform", "translate(" + Math.max(0, (width * ((scrollY - firstCases[justiceId]) / runningTotalData.length))) + ",0)");

    };

  var updateJusticeViewSelection = function(scrollY) {
    if (!d3.select(".justiceView").empty()) {
      var justiceId = +d3.select(".justiceView").attr("justiceId");
      var width = +d3.select(".justiceView").attr("graphWidth");
      d3.select(".selection").attr("transform", "translate(" + Math.max(0, (width * ((scrollY - firstCases[justiceId]) / (lastCases[justiceId] - firstCases[justiceId] - 1)))) + ",0)");
    }
  }

});

});

</script>
  
</html>

